# 复杂度分析

    复杂度分析犹如浩瀚的算法宇宙中的时空向导。它带领我们在时间与空间这两个维度上深入探索，寻找更优雅的解决方案。

### 算法效率评估

在算法设计中，我们先后追求以下两个层面的目标。

* 找到问题解法：算法需要在规定的输入范围内，可靠地求得问题的正确结果。
* 寻求最优解法：同一个问题可能存在多种解法，我们希望找到尽可能高效的算法。

也就是说，在能够解决问题的前提下，算法效率已成为衡量算法优劣的主要评价指标，它包括以下两个维度。

* <b>时间效率</b>：算法运行速度的快慢。
* <b>空间效率</b>：算法占用内存空间的大。

简而言之，我们的目标是设计“既快又省”的数据结构与算法。而有效地评估算法效率至关重要，因为只有这样我们才能将各种算法进行对比，从而指导算法设计与优化过程。
效率评估方法主要分为两种：实际测试、理论估算。

##### 实际测试

假设我们对某一个问题，有着两种解决方案A,B; 实际测试就是找两台PC跑两段逻辑，并统计它们各自的所花费时间和所占用内存空间来进行对比; 但他们会受到以下几个方面的影响：

1. PC硬件配置的不同会很大程度上影响对比结果;
2. 对于输入数据的大小不同，对应执行时间也会受到很大影响;

##### 理论估算

针对实际测试的局限性，我们可以考虑仅通过一些计算来评估算法的效率。这种估算方法被称为「渐近复杂度分析 asymptotic complexity analysis」，简称「复杂度分析」。

复杂度分析体现算法运行所需的时间（空间）资源与输入数据大小之间的关系。它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势。

复杂度分析克服了实际测试方法的弊端，体现在以下两个方面：

1. 它独立于测试环境，分析结果适用于所有运行平台。
2. 它可以体现不同数据量下的算法效率，尤其是在大数据量下的算法性能。

#### 时间复杂度

运行时间可以直观且准确地反映算法的效率。如果我们想要准确预估一段代码的运行时间，应该如何操作呢?

1. 最原始的方法就是通过在代码片段中在方法前后记录开始和结束时间来统计这段代码的运行时间；但这样统计并不合理，首先就是宿主机的设备情况会大大影响统计的结果，硬件配置、编程语言、系统环境等，这些因素都会影响代码的运行效率；

2. 统计时间增长趋势：时间复杂度分析统计的不是算法运行时间，而是算法运行时间随着数据量变大时的增长趋势；
   
   ```c
   // 算法 A 的时间复杂度：常数阶
   void algorithm_A(int n) {
      printf("%d", 0);
   }
   // 算法 B 的时间复杂度：线性阶
   void algorithm_B(int n) {
     for (int i = 0; i < n; i++) {
        printf("%d", 0);
     }
   }
   // 算法 C 的时间复杂度：常数阶
   void algorithm_C(int n) {
     for (int i = 0; i < 1000000; i++) {
        printf("%d", 0);
     }
   }
   ```
* 算法A只有1个打印操作，算法运行时间不随着 增大而增长。我们称此算法的时间复杂度为“常数阶(O(1))” 。
* 算法B中的打印操作需要循环n次，算法运行时间随着n的增大呈线性增长。此算法的时间复杂度被称为“线性阶(O(N))”。
* 算法C中的打印操作需要循环1000000次，虽然运行时间很长，但它与输入数据大小n无关。因此C的时间复杂度和A相同，仍为“常数阶(O(1))”。

相较于直接统计算法运行时间，时间复杂度分析有哪些特点呢？

* 时间复杂度能够有效评估算法效率。例如，算法B的运行时间呈线性增长，在n>1时比算法A更慢，在n>1000000时比算法C更慢。事实上，只要输入数据大小n足够大，复杂度为“常数阶”的算法一定优于“线性阶”的算法，这正是时间增长趋势所表达的含义。

* 时间复杂度的推算方法更简便。显然，运行平台和计算操作类型都与算法运行时间的增长趋势无关。因此在时间复杂度分析中，我们可以简单地将所有计算操作的执行时间视为相同的“单位时间”，从而将“计算操作的运行时间的统计”简化为“计算操作的数量的统计”，这样一来估算难度就大大降低了。

* 时间复杂度也存在一定的局限性。例如，尽管算法A和C的时间复杂度相同，但实际运行时间差别很大。同样，尽管算法B的时间复杂度比C高，但在输入数据大小n较小时，算法B明显优于算法C 。在这些情况下，我们很难仅凭时间复杂度判断算法效率的高低。当然，尽管存在上述问题，复杂度分析仍然是评判算法效率最有效且常用的方法。



<img src="file:///E:/user%20document/Personal-Knowledge-base/picture%20service/dataStructures/2.png" title="" alt="" data-align="center">



- [ ] 推算方法

- [ ] 常见表示类型

- [ ] 最差、最佳、平均时间复杂度

#### 空间复杂度

「空间复杂度 space complexity」用于衡量算法占用内存空间随着数据量变大时的增长趋势。这个概念与时间复杂度非常类似，只需将“运行时间”替换为“占用内存空间”。

##### 算法相关占用空间名词

算法在运行过程中使用的内存空间主要包括以下几种:

* 输入空间：用于存储算法的输入数据。
* 暂存空间：用于存储算法在运行过程中的变量、对象、函数上下文等数据。
* 输出空间：用于存储算法的输出数据。
  一般情况下，空间复杂度的统计范围是“暂存空间”加上“输出空间”。

暂存空间可以进一步划分为三个部分:

* 暂存数据：用于保存算法运行过程中的各种常量、变量、对象等。
* 栈帧空间：用于保存调用函数的上下文数据。系统在每次调用函数时都会在栈顶部创建一个栈帧，函数返回后，栈帧空间会被释放。
* 指令空间：用于保存编译后的程序指令，在实际统计中通常忽略不计。

```c
/* 函数 */
int func() {
    // 执行某些操作...
    return 0;
}

int algorithm(int n) { // 输入数据
    const int a = 0;   // 暂存数据（常量）
    int b = 0;         // 暂存数据（变量）
    int c = func();    // 栈帧空间（调用函数）
    return a + b + c;  // 输出数据
}
```

- [ ] 知识点补充 
