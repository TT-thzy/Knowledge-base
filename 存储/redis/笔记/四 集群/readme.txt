上次课：
redis事务
multi：开启
exec：执行
discard：放弃
watch：监控key
unwatch：放弃key监视
=========================================================================


八、Redis复制【集群】（master/slave）☆☆☆☆重中之重☆☆☆☆☆
前提：所有集群中的redis版本一定要一致

1.主从(课堂案例采用一两三从的演示效果)
实际的工作中是三台电脑，不同的ip地址，每台上面都启用6379端口，形成集群
我的演示效果是同一台及其开启三个不同的端口，相同的ip，不同的端口形成集群模拟
a:因为redis服务启动需要指定配置文件，所以我首先将配置文件copy两份
修改文件名以及里面的配置信息
0）修改daemonize yes（这个只在linux系统上模拟要改）
1）修改pidfile /var/run/redis6380.pid文件名（这个只在linux系统上模拟要改）
2）修改port 6380（这个模拟都要修改）☆☆☆☆☆☆
3）修改logfile "log6380.log"（这个只在linux系统上模拟要改）
4）修改dbfilename dump6380.rdb（这个模拟都要修改）☆☆☆☆☆☆

b:启动三台redis（分别占据6379,6380,6381端口）
使用info replication来查看当前机器是master还是slaver信息及状态
在丛机上使用命令slaveof 主机ip 端口来进行主从同步

c:测试

流程：1.丛机敲slaveof命令后向主机发送sync标志
      2.主机接收到sync标志信息后，会直接使用bgsave保存当前的数据存盘
      同时将正在写入的命令存入缓存区，当bgsave结束，发送给slave产生
      丛机的rdb数据库文件，另外清空缓冲区，将缓冲区的内容再发给丛机，
      丛机同步主机结束（这个过程叫全局复制）
      3.以后，主机再每次有写的操作，都会即时同步给丛机
      （这个过程叫增量复制）

主从复制，读写分离（丛机是只读的，不可以写）
一、一主二【多】从
A:如果主机挂了，丛机不会自动提升变为主机，主机被激活后，
会仍然作为主机，并且下面的丛机是自动连上
B:如果丛机挂了，丛机被激活后，不会自动同步主机的数据，
一定要再次进行全局复制，才可以继续同步


二、为了减轻主机压力，我们可以采用薪火相传的方式
丛机下面也可以再挂丛机，那么虽然相对而言这台丛机的角色是
主机，但是只要使用info replication的角色是slave，它也只能
进行读操作


三、反客为主（主机挂了，从机里面找个老大）
如果主机挂了，短时间一直无法修复，那么我们应该在
剩下的丛机里面找一个作为master，我们可以使用
slaveof no one将某台丛机提升为主机，然后让其它丛机
从新拜老大为这台新的主机.
如果原来的主机重新上线，因为数据不会是最新的，一般会让它
作为丛机去同步现在的主机





2.哨兵（巡逻的,监视的）---它应该是另外一台机器,来监控M,S,T的
就是上面反客为主的自动版(负责来支持选举的人)
在redis的目录下面新建一个文件名为
sentinel.conf的配置文件,里面的内容如下：
sentinel monitor 主机别名 主机ip 主机端口 需要多少人投票赞同
投票的决策一般根据下面3个原则执行
a：优先级低的为主slave_priority
b：如果级别一样，以复制更完整的优先
c：如果完整度也一样，那么id小的优先
启动哨兵：
redis-server sentinel.conf --sentinel
在linux系统中有一个redis-sentinel-server专门启动哨兵

流程：
每个哨兵以每秒1次的频率向集群中的M，S，T发送ping命令确认是否下线
如果一个实例距离最后一次ping的回复超过down-after-milliseconds指定值则
标记为主观下线（SDOWN【哨兵认为】）
如果一个M标记为主观下线，那么监视这个M的T要以每秒1次的频率确认，当足够数量的
T认为该M为主观下线，那么标记为客观下线（ODOWN【真正下线】）
然后T会每秒1次的向该M下的S发送info命令。
没有足够数量的T同意M为SDOWN，则移除ODOWN标记，若M重新回复ping命令，则SDOWN标记移除



3.cluster集群（分布式集群【槽slot：0-16383】）(ruby)
流程：
所有的分布式的子集群地位相同，用户可以任意连接其中一个节点，
互相之间使用ping-pong机制来确认是否失效.
当集群中超过半数的节点检测认为失效，才确认为失效.
在集群中每一个节点上都有一个slot(槽),它的取值范围是0-16383之间.
当有一个key需要存储的时候，集群首先对该key使用crc16的算法得到一个
结果，然后将这个结果对16384取余，那么该key通过上面计算得到的值
就是我们说的哈希槽,然后放到相应的节点上，查询与修改等都是如此，
会直接找到对应的子集群




九、Jedis
java操作redis